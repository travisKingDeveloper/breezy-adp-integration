'use strict'

const mongo = require('../../db/mongoClient')()
const helpers = require('../../util/helpers')
const userClient = require('../user/core-user')
const memberClient = require('./core-member')
const applicationClient = require('../application/application-settings')
const teamClient = require('./core-team')
const {getConfig} = require('../../util/breezy-config')
const moment = require('moment')

const LOG_NS = '[CORE-COMPANY]'
const COMPANY_CACHE_KEY = 'BREEZY_COMPANY_'
const COMPANY_FEATURES_CACHE_KEY = 'BREEZY_COMPANY_FEATURES_'
const COMPANY_COLLECTION = 'company'
const COMPANY_USER_SETTINGS_COLLECTION = 'company_user_settings'
const COMPANY_FEATURES_COLLECTION = 'company_feature'
const COMPANY_OPTIONS = {
  COMPANY_FEATURES: 1 << 0
}

module.exports = {
  getCompanyMembers,
  getCompanyById,
  populateCompanyUserMeta,
  COMPANY_OPTIONS
}

/**
 * Gets a company by id
 * @param companyId
 * @param {number} options (bit mask of COMPANY_OPTIONS
 * @returns {Promise<Company>}
 */
async function getCompanyById(companyId, options = 0) {

  let company = await _getBaseCompany(companyId)

  if (!company) {
    return company
  }

  company = _finalize(company)

  if (options & COMPANY_OPTIONS.COMPANY_FEATURES) {
    company = await _applyCompanyFeatures(company)
  }

  return company
}

/**
 * Sends a company to cache
 * @param company
 * @private
 */
function _cacheCompany(company) {
  if (company) {
    let id = company._id
    helpers.cache.chooseCache(id).set(COMPANY_CACHE_KEY + id, JSON.stringify(company), 3600, function (error, value) {
    })
  }
}

/**
 * Gets a company from cache
 * @param companyId
 * @returns {Promise<any>}
 */
async function _getCompanyFromCache(companyId) {
  let company = await helpers.cache.chooseCache(companyId).getAsync(COMPANY_CACHE_KEY + companyId)
  if (company) {
    return JSON.parse(company)
  }
  return company
}

/**
 * Builds a basic company from cache or db...
 * @param companyId
 * @returns {Promise<*|any|any>}
 * @private
 */
async function _getBaseCompany(companyId) {

  let company = await _getCompanyFromCache(companyId)
  if (company) {
    return company
  }

  company = await _getCompany({'_id': companyId})

  _cacheCompany(company)

  return company

}

/**
 * Gets a company from mongo
 * @param criteria
 * @returns {Promise<*>}
 */
async function _getCompany(criteria) {

  try {
    return mongo.getDocumentAsync({
      collection: COMPANY_COLLECTION,
      criteria: criteria
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 * modifies a company with role data
 * @param company
 * @private
 */
function _finalize(company) {

  if (company.creation_date) {
    company.creation_date = new Date(company.creation_date)
  }
  if (company.trial_date) {
    company.trial_date = new Date(company.trial_date)
  }
  if (!company.trial_expiry_date) {
    company.trial_expiry_date = new Date('2014-12-20')
  }
  let words = company.name.trim().toUpperCase().split(' ')
  if (words.length > 1) {
    company.initial = words[0].replace(/[^A-Za-z0-9 ]/, '').substring(0, 1) + words[1].replace(/[^A-Za-z0-9 ]/, '').substring(0, 1)
  } else {
    company.initial = company.name.trim().replace(/[^A-Za-z0-9 ]/, '').substring(0, 1).toUpperCase()
  }
  return company
}

/**
 * modifies a company with the feature details
 * @param company
 * @returns {Promise<void>}
 * @private
 */
async function _applyCompanyFeatures(company) {

  let features = await helpers.cache.chooseCache(company._id).getAsync(COMPANY_FEATURES_CACHE_KEY + company._id)
  if (features) {
    company.features = JSON.parse(features)
    return company
  }

  try {
    features = await mongo.getDocumentAsync({
      collection: COMPANY_FEATURES_COLLECTION,
      criteria: {'_id': company._id}
    })
  } catch (e) {
    console.error(e)
    return company
  }

  let finalizedFeatures = helpers.getCompanyFeatures(company, features)
  company.features = finalizedFeatures
  //cache computed features with overrides (24h)
  helpers.cache.chooseCache(company._id).set(COMPANY_FEATURES_CACHE_KEY + company._id, JSON.stringify(finalizedFeatures), 86400, function (error, value) {

  })
  return company
}

/**
 * Gets company members for the provided company
 * @param company
 * @returns {Promise<Array|*>}
 */
async function getCompanyMembers(company) {

  let users = []

  if (!company) {
    console.log('No company found : ' + companyId)
    return users
  }

  let members = await memberClient.getMembersByCompanyId(company._id)
  if (!members) {
    console.log('No members for companyId : ' + company._id)
    return users
  }

  for (let member of members) {
    let userId = member.user_id

    let user
    try {
      user = await userClient.getUserById(userId)
      if (user) {
        users.push(user)
      }
    } catch (e) {
      console.error(LOG_NS, e)
    }
  }

  return helpers.sortObjectArrayByKey(users, 'name', 'asc')
}

/**
 * populateCompanyUserMeta
 * @param {string} companyId
 * @param {object} user
 * @returns {Promise<*>}
 */
async function populateCompanyUserMeta(companyId, user) {

  let settings = getCompanyUserSettings(companyId, user)
  let teamIds = teamClient.getUserCompanyTeamIds(companyId, user._id)

  Object.assign(user, {
    team_ids: await teamIds,
    company_settings: await settings
  })

  return user
}

/**
 * getCompanyUserSettings
 * @param {string} companyId
 * @param {object} user
 * @returns {Promise<*>}
 */
async function getCompanyUserSettings(companyId, user) {
  let userId = user._id
  let userSettings = await mongo.getDocumentAsync({
    collection: COMPANY_USER_SETTINGS_COLLECTION,
    criteria: {
      'company_id': companyId,
      'user_id': userId
    }
  })

  if (!userSettings) {
    userSettings = {}
  }

  let appSettings = await applicationClient.getApplicationSettings()

  userSettings.webcal_uri = getConfig.breezy_base_url + 'icalendar/' + companyId + '/' + userId + '/' + helpers.getHashId(companyId + '_' + userId) + '/calendar.ics'

  userSettings.terms_consent_needed = (!(
    user.hasOwnProperty('terms') &&
    moment(user.terms).isValid() &&
    appSettings.hasOwnProperty('tos_date') &&
    moment(user.terms).diff(moment(appSettings.tos_date), 'second') > 0))

  return userSettings
}












