'use strict'

const mongo = require('../../db/mongoClient')()
const helpers = require('../../util/helpers')
const LOG_NS = '[CORE-CUE]'
const CUE_CACHE_KEY = 'BREEZY_CUE_'
const CUE_COLLECTION = 'company_cue'

/*
SCHEMA - COMPANY_CUE

{
  _id (company_id)
  <company_cue>: bool
  updated_date
}

*/

//this should be populated with valid company_cues that we add to the system
var ALLOWED_CUES = ['sources_initialized', 'gdpr_templates', 'sourcers_initialized'];

module.exports = {
  getCompanyCues: getCompanyCues,
  getCompanyCue: getCompanyCue,
  setCompanyCue: setCompanyCue
};

// data{company, actingUser}
async function getCompanyCues(data) {

  let cues = await getCueFromCache(data.company._id)
  if (cues) {
    return cues
  }

  let criteria = {
    _id: data.company._id,
  };

  cues = await mongo.getDocumentAsync({
    collection: CUE_COLLECTION,
    criteria: criteria
  })

  if (!cues) {
    cues = await mongo.putDocumentAsync({
      collection: CUE_COLLECTION,
      doc: {_id: data.company._id}
    })
  }

  cacheCue(data.company._id, cues)

  return cues
}

// data{ cue, value, company, actingUser }
function setCompanyCue(data) {
  var cue = data.cue,
    cueValue = data.value,
    company = data.company,
    actingUser = data.actingUser,
    updates = {};

  if (!isCueValid(cue)) return Promise.reject({error: 'cue is not valid'});

  return getCompanyCues({company: data.company})
    .then(function (result) {

      updates[cue] = cueValue;
      updates['updated_date'] = new Date();

      return mongo.findAndModifyAsync({
        collection: CUE_COLLECTION,
        criteria: {_id: data.company._id},
        updates: updates
      });
    });
}

// data{ cue, company, actingUser }
function getCompanyCue(data) {
  return getCompanyCues(data)
    .then(function (result) {
      if (!result || !result.hasOwnProperty(data.cue) || result[data.cue] === false)
        return false;

      return true;
    })
}

// data{cue}
function isCueValid(cue) {
  return (ALLOWED_CUES.indexOf(cue) > -1)
}

/**
 * Gets a cue from cache
 * @param companyId
 * @returns {Promise<any>}
 */
async function getCueFromCache(companyId) {

  let cue = await helpers.cache.chooseCache(companyId).getAsync(CUE_CACHE_KEY + companyId)
  if (cue) {
    return JSON.parse(cue)
  } else {
    return cue
  }
}

function cacheCue(companyId, cue) {

  helpers.cache.chooseCache(companyId).set(CUE_CACHE_KEY + companyId, JSON.stringify(cue), 43200, function (error, value) {
  })
}

