'use strict'

const zlib = require('zlib')
const LOG_NS = '[CORE-REDIS]'
const {getConfig} = require('../../util/breezy-config')
const config = getConfig().Redis

let redisClient

module.exports = function () {

  if (!config.PORT || !config.HOST) {
    return {}
  }

  if (!redisClient) {
    redisClient = require('redis').createClient({
      port: config.PORT,
      host: config.HOST,
      enable_offline_queue: false,
      retry_strategy: function (options) {
        return Math.max(options.attempt * 100, 3000)
      }
    })

    redisClient.on('error', function (error) {
      console.error(LOG_NS, error)
    })

    redisClient.on('reconnecting', function (stats) {
      console.log(LOG_NS, 'reconnecting to server @ ' + config.HOST + ':' + config.PORT + ' - next retry (' + stats.attempt + ') in ' + stats.delay + 'ms')
    })

    redisClient.on('end', function (e) {
      console.error(LOG_NS, 'end', e)
    })
    redisClient.on('ready', function () {
      console.log(LOG_NS, 'connected to server @ ' + config.HOST + ':' + config.PORT)
    })
  }

  let redis = {}

  redis.get = function (key, callback) {
    //console.log(LOG_NS, '- getting', key)
    redisClient.get(key, function (err, res) {
      if (res) {
        try {
          const buffer = Buffer.from(res, 'base64')
          zlib.unzip(buffer, (error, buffer) => {
            if (error) {
              console.error(LOG_NS, '[ZLIB]', error)
              return callback(err, res)
            } else {
              return callback(error, buffer.toString())
            }
          })
        } catch (e) {
          console.error(LOG_NS, '[ZLIB]', e)
          return callback(err, res)
        }
      } else {
        return callback(err, res)
      }
    })
  }

  redis.getAsync = function (key) {
    return new Promise(function (resolve, reject) {
      redis.get(key, function (err, result) {
        if (err) return reject(err)
        return resolve(result)
      })
    })
  }

  redis.hmget = function (key, field, callback) {
    redisClient.hmget(key, field, callback)
  }

  redis.hgetall = function (key, callback) {
    redisClient.hgetall(key, callback)
  }

  redis.set = function (key, value, expiration, callback) {
    // console.log(LOG_NS, '- setting', key)
    if (typeof (expiration) === 'function') {
      callback = expiration
      expiration = undefined
    }
    if (typeof value === 'object') {
      value = JSON.stringify(value)
    }

    zlib.deflate(value, (err, buffer) => {
      if (!err) {
        redisClient.set(key, buffer.toString('base64'), function (error, response) {
          if (expiration) {
            redisClient.expire(key, expiration, function () {
            })
          }
          return callback(error, response)
        })

      } else {
        console.error(LOG_NS, '[ZLIB]', err)
      }
    })

  }

  redis.zadd = function (key, score, field, expiration, callback) {
    if (typeof (expiration) === 'function') {
      callback = expiration
      expiration = undefined
    }
    if (typeof field === 'object') {
      field = JSON.stringify(field)
    }
    redisClient.zadd(key, score, field, function (error, response) {
      if (expiration) {
        redisClient.expire(key, expiration, function () {
        })
      }
      return callback(error, response)
    })
  }

  redis.zrangebyscore = function (key, start, stop, callback) {
    redisClient.zrangebyscore(key, start, stop, callback)
  }

  redis.zremrangebyscore = function (key, start, stop, callback) {
    redisClient.zremrangebyscore(key, start, stop, callback)
  }

  redis.zremrangebyrank = function (key, min, max, callback) {
    redisClient.zremrangebyrank(key, min, max, callback)
  }

  redis.zrange = function (key, start, stop, callback) {
    redisClient.zrange(key, start, stop, callback)
  }

  redis.zscore = function (key, field, callback) {
    redisClient.zscore(key, field, callback)
  }

  redis.delete = function (key, callback) {
    redisClient.del(key, callback)
  }

  redis.expire = function (key, time, callback) {
    redisClient.expire(key, time, callback)
  }

  let nocache = {}

  Object.assign(nocache, redis)

  nocache.get = function (key, callback) {
    return callback()
  }

  nocache.getAsync = async function (key) {
  }

  redis.nocache = nocache

  return redis
}
