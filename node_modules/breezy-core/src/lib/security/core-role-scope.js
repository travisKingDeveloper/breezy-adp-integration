'use strict'

const mongo = require('../../db/mongoClient')()
const securityConfig = require('../../../data/security-config')
const securityCache = require('../security/core-security-cache')
const teamClient = require('../../lib/company/core-team')
const helpers = require('../../util/helpers')
const LOG_NS = '[CORE-ROLE-SCOPE]'
const SCOPE_CACHE_KEY = 'BREEZY_ROLE_SCOPE_'
const SCOPE_COLLECTION = 'role_scope'
const SCOPE_AUDIT_COLLECTION = 'role_scope_audit'

module.exports = {
  getPositionMembers,
  addMemberToPosition,
  addTeamToPosition,
  removeMemberFromPosition,
  removeTeamFromPosition,
  getMemberPositions,
  getPositionMembersByRole,
  canRemoveMember,
  removeMemberScopes,
  migratePositionRoleMembers,
  removePositionRoleScope,
  removeAllRoleScopes,
  getMembersAndPositionsByRole,
  getAllCompanyScopes,
  createRoleScopeAudit,
  updateRoleScopeAudit
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} userId
 * @param {string} role
 * @returns {Promise<void>}
 */
async function addMemberToPosition(companyId, positionId, userId, role) {

  await updateCompanyScope(
    {company_id: companyId, position_id: positionId, role: role},
    {$addToSet: {members: userId}},
    {upsert: true})

  securityCache.invalidateCache(companyId, userId)
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} teamId
 * @param {string} role
 * @returns {Promise<void>}
 */
async function addTeamToPosition(companyId, positionId, teamId, role) {

  let ids = await teamClient.getCompanyTeamMemberIds(companyId, teamId)

  await updateCompanyScope(
    {company_id: companyId, position_id: positionId, role: role},
    {$addToSet: {teams: teamId}},
    {upsert: true})

  for (let id of ids) {
    securityCache.invalidateCache(companyId, id)
  }
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} userId
 * @param {string} [role]
 * @returns {Promise<void>}
 */
async function removeMemberFromPosition(companyId, positionId, userId, role) {

  if (role) {

    if (await canRemoveMember(companyId, positionId, role)) {

      await updateCompanyScope(
        {company_id: companyId, position_id: positionId, role: role},
        {$pull: {members: userId}})

      securityCache.invalidateCache(companyId, userId)
    }
  } else {

    await updateCompanyScope(
      {company_id: companyId, position_id: positionId},
      {$pull: {members: userId}},
      {multi: true})

    securityCache.invalidateCache(companyId, userId)
  }
}

/**
 * Remove a team from position, specifying a role will remove the team only from that role on a position
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} teamId
 * @param {string} [role]
 * @returns {Promise<void>}
 */
async function removeTeamFromPosition(companyId, positionId, teamId, role) {

  let ids = await teamClient.getCompanyTeamMemberIds(companyId, teamId)

  if (role) {

    await updateCompanyScope(
      {company_id: companyId, position_id: positionId, role: role},
      {$pull: {teams: teamId}})
  } else {

    await updateCompanyScope(
      {company_id: companyId, position_id: positionId},
      {$pull: {teams: teamId}},
      {multi: true})
  }

  for (let id of ids) {
    securityCache.invalidateCache(companyId, id)
  }
}

/**
 *
 * @param {string} companyId
 * @param {string} memberId
 * @param {Array<string>} [teams]
 * @returns {Promise<*>}
 */
async function getMemberPositions(companyId, memberId, teams) {

  if (teams && (teams.length > 0)) {
    return getCompanyScope({
      company_id: companyId,
      $or: [{members: memberId}, {teams: {$elemMatch: {$in: teams}}}]
    })
  } else {
    return getCompanyScope({company_id: companyId, members: memberId})
  }
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @returns {Promise<*|undefined>}
 */
async function getPositionMembers(companyId, positionId) {
  return getCompanyScope({company_id: companyId, position_id: positionId})
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} role
 * @returns {Promise<*|undefined>}
 */
async function getPositionMembersByRole(companyId, positionId, role) {
  return getCompanyScope({company_id: companyId, position_id: positionId, role: role})
}

/**
 *
 * @param {string} companyId
 * @param {string} role
 * @returns {Promise<*|undefined>}
 */
async function getMembersAndPositionsByRole(companyId, role) {
  return getCompanyScope({company_id: companyId, role: role})
}

/**
 *
 * @param {object} criteria
 * @returns {Promise<*>}
 */
async function getCompanyScope(criteria) {

  try {
    return await mongo.getDocumentsAsync({
      collection: SCOPE_COLLECTION,
      criteria: criteria
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 *
 * @param {object} criteria
 * @param {object} updates
 * @param {object} [options]
 * @returns {Promise<void>}
 */
async function updateCompanyScope(criteria, updates, options = {}) {

  try {
    return await mongo.updateDocumentAsync({
      collection: SCOPE_COLLECTION,
      criteria: criteria,
      updates: updates,
      options: options
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 * checks if a role has a min number of members and validates that a remove operation could be performed
 * @param companyId
 * @param positionId
 * @param role
 * @returns {Promise<boolean>}
 * @private
 */
async function canRemoveMember(companyId, positionId, role) {

  let memberMin = 0
  for (let defaultRole of securityConfig.defaultRoles) {
    if (defaultRole._id === role && defaultRole.min_users) {
      memberMin = defaultRole.min_users
    }
  }

  if (memberMin > 0) {
    let positionRole = await getPositionMembersByRole(companyId, positionId, role)
    if (!positionRole || !positionRole.members || (positionRole.members.length <= memberMin)) {
      return false
    }
  }
  return true
}

/**
 *
 * @param companyId
 * @param source
 * @param target
 * @returns {Promise<void>}
 */
async function migratePositionRoleMembers(companyId, source, target) {

  let migratedScopes = await mongo.getDocumentsAsync({
    collection: SCOPE_COLLECTION,
    criteria: {company_id: companyId, role: source},
    limit: 1000
  })

  await updateCompanyScope(
    {company_id: companyId, role: source},
    {$set: {role: target}},
    {multi: true})

  console.log(LOG_NS, 'Clearing security cache for', migratedScopes.length, 'company members migrated from', source, 'to', target)
  for (let member of migratedScopes) {
    let memberId = member.user_id
    securityCache.invalidateCache(companyId, memberId)
  }
}

/**
 *
 * @param companyId
 * @param userId
 * @returns {Promise<void>}
 */
async function removeMemberScopes(companyId, userId) {

  await updateCompanyScope(
    {company_id: companyId, members: userId},
    {$pull: {members: userId}},
    {multi: true})
}

/**
 *
 * @param companyId
 * @param roleId
 * @returns {Promise<void>}
 */
async function removePositionRoleScope(companyId, roleId) {

  await mongo.deleteDocumentAsync({
    collection: SCOPE_COLLECTION,
    criteria: {company_id: companyId, role: roleId}
  })
}

/**
 *
 * @param companyId
 * @returns {Promise<void>}
 */
async function getAllCompanyScopes(companyId) {

  return getCompanyScope({company_id: companyId})
}

/**
 *
 * @param companyId
 * @returns {Promise<void>}
 */
async function removeAllRoleScopes(companyId) {

  await mongo.deleteDocumentAsync({
    collection: SCOPE_COLLECTION,
    criteria: {company_id: companyId}
  })
}

/**********************************************************************************************************************
 Role Scope Audits
 ***********************************************************************************************************************/

async function updateRoleScopeAudit(auditId, stageName, state) {

  let updates = {}
  updates[stageName] = state

  return _updateRoleScopeAudit({_id: auditId},
    {$set: updates})
}

/**
 *
 * @param criteria
 * @param updates
 * @param options
 * @returns {Promise<void>}
 */
async function _updateRoleScopeAudit(criteria, updates, options = {}) {

  try {
    return await mongo.updateDocumentAsync({
      collection: SCOPE_AUDIT_COLLECTION,
      criteria: criteria,
      updates: updates,
      options: options
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 *
 * @param companyId
 * @param reason
 * @param state
 * @returns {Promise<void>}
 */
async function createRoleScopeAudit(companyId, reason, state) {

  let audit = {
    _id : helpers.getId(companyId),
    company_id: companyId,
    reason: reason,
    date: new Date(),
    initial: state
  }

  return await mongo.putDocumentAsync({
    collection: SCOPE_AUDIT_COLLECTION,
    doc: audit
  })
}