'use strict'

const mongo = require('../../db/mongoClient')()
const helpers = require('../../util/helpers');
const memberClient = require('../../lib/company/core-member')
const roleScopeClient = require('../../lib/security/core-role-scope')
const {defaultRoles, ROLE, ROLE_TYPE} = require('../../../data/security-config')
const LOG_NS = '[CORE-ROLE]'
const SECURITY_ROLE_COLLECTION_NAME = 'security_role'

module.exports = {
  getCompanyRoles,
  deleteAllRoles,
  customRolesEnabled,
  createRole,
  getRoles,
  getRole,
  updateRole,
  deleteRole,
  initializeRoles,
  getDefaultRoles,
  downgradeRoles
}

/**
 * @typedef {object} Role
 * @property {string} _id
 * @property {string} company_id
 * @property {string} name
 * @property {string} description
 * @property {Array<Permission>} permissions
 */

/**
 * Determines if custom roles are available
 * @param company
 * @returns {Promise<boolean>}
 */
async function customRolesEnabled(company) {
  return company.features.role_based_security
}

/**
 * create a new role
 * @param {Role} role
 * @param {string} companyId
 * @returns {Promise<Role>}
 */
async function createRole(role, companyId) {
  console.log(LOG_NS, 'createRole')

  let newRole = {}
  newRole._id = helpers.getId(companyId)
  newRole.name = role.name
  newRole.company_id = companyId
  newRole.type = role.type
  if (role.parent) {
    newRole.parent = role.parent
  }
  newRole.created = new Date()
  newRole.immutable = role.immutable
  newRole.description = role.description ? role.description : ''
  newRole.permissions = _cleanPermissions(role.permissions)

  return await mongo.putDocumentAsync({
    collection: SECURITY_ROLE_COLLECTION_NAME,
    doc: newRole
  })
}

async function getCompanyRoles(company) {

  let roles

  if (await customRolesEnabled(company)) {

    try {
      roles = await getRoles(company._id)
    } catch (e) {
      console.error(LOG_NS, e)
    }

  }

  if (!roles || !roles.length) {
    roles = getDefaultRoles(company.settings.ats.candidate_management_company_admin)
  } else {
    for (let role of getDefaultRoles(company.settings.ats.candidate_management_company_admin)) {
      if (role.immutable) {
        roles.push(role)
      }
    }
  }
  return roles
}

/**
 * Collect them all
 * @param companyId
 * @returns {Promise<Array<Role>>}
 */
async function getRoles(companyId) {

  return await mongo.getDocumentsAsync({
    collection: SECURITY_ROLE_COLLECTION_NAME,
    criteria: {company_id: companyId},
    limit: 20
  })
}

/**
 * Gets defaults and filters admin and sys admin by ats settings
 * the key : company.settings.ats.candidate_management_company_admin
 * true returns admin and false returns sys_admin (without candidate control)
 * @param {boolean} [candidateManagementCompanyAdmin]
 * @returns {[]}
 */
function getDefaultRoles(candidateManagementCompanyAdmin = true) {
  let roles = []

  for (let defaultRole of defaultRoles) {
    if (ROLE.SYSTEM_ONLY === defaultRole._id) {
      if (!candidateManagementCompanyAdmin) {
        roles.push(defaultRole)
      }
    } else if (ROLE.COMPANY_ADMIN === defaultRole._id) {
      if (candidateManagementCompanyAdmin) {
        roles.push(defaultRole)
      }
    } else {
      roles.push(defaultRole)
    }
  }
  return roles
}

/**
 * Collect them all
 * @param companyId
 * @param roleId
 * @returns {Promise<Array<Role>>}
 */
async function getRole(companyId, roleId) {

  for (let role of getDefaultRoles()) {
    if (roleId===role._id && role.immutable) {
      return role
    }
  }

  return await mongo.getDocumentAsync({
    collection: SECURITY_ROLE_COLLECTION_NAME,
    criteria: {_id: roleId, company_id: companyId}
  })
}

/**
 * Make a change to a role
 * @param roleId
 * @param role
 * @param companyId
 * @returns {Promise<Role>}
 */
async function updateRole(roleId, role, companyId) {

  let updates = {}
  updates.name = role.name
  updates.modified = new Date()
  updates.description = role.description ? role.description : ''
  updates.permissions = _cleanPermissions(role.permissions)

  return await mongo.findAndModifyAsync({
    collection: SECURITY_ROLE_COLLECTION_NAME,
    criteria: {_id: roleId, company_id: companyId},
    updates: updates
  })
}

/**
 * db call to remove a role
 * @param roleId
 * @param companyId
 * @returns {Promise<*>}
 * @private
 */
async function deleteRole(roleId, companyId) {

  return mongo.deleteDocumentAsync({
    collection: SECURITY_ROLE_COLLECTION_NAME,
    criteria: {_id: roleId, company_id: companyId}
  })
}

/**
 *
 * @param role
 * @param companyId
 * @returns {Promise<*>}
 */
async function deleteRoleMigrateMembers(role, companyId) {

  if (role) {
    if (role.type === ROLE_TYPE.POSITION) {
      let scopes = await roleScopeClient.getAllCompanyScopes(companyId)
      let audit = await roleScopeClient.createRoleScopeAudit(companyId, role._id + ' role deleted', scopes)

      await roleScopeClient.migratePositionRoleMembers(companyId, role._id, ROLE.POSITION_MEMBER)
      await roleScopeClient.removePositionRoleScope(companyId, role._id)

      scopes = await roleScopeClient.getAllCompanyScopes(companyId)
      await roleScopeClient.updateRoleScopeAudit(audit._id, 'final', scopes)
    } else if (role.type === ROLE_TYPE.COMPANY) {
      await memberClient.migrateCompanyRoleMembers(companyId, role._id)
    }
    await deleteRole(role._id, companyId)
  }
}

/**
 * Get rid of all roles for a company
 * @param companyId
 * @returns {Promise<*>}
 */
async function deleteAllRoles(companyId) {

  let roles = await getRoles(companyId)

  for (let role of roles) {
    if (!role.immutable) {
      await deleteRoleMigrateMembers(role, companyId)
    }
  }
}

/**
 * removes old custom roles and imports new ones
 * @param companyId
 * @param {boolean} [candidateManagementCompanyAdmin]
 * @returns {Promise<[]>}
 */
async function initializeRoles(companyId, candidateManagementCompanyAdmin = true) {

  let newRoles = []

  let scopes = await roleScopeClient.getAllCompanyScopes(companyId)
  let audit = await roleScopeClient.createRoleScopeAudit(companyId, 'init custom roles', scopes)

  for (let role of getDefaultRoles()) {
    try {
      if (!role.immutable) {
        let newRoleFromDefault = Object.assign({}, role)
        newRoleFromDefault.parent = {}
        newRoleFromDefault.parent._id = role._id
        let newRole = await createRole(newRoleFromDefault, companyId)
        if (role.type === ROLE_TYPE.POSITION) {
          await roleScopeClient.migratePositionRoleMembers(companyId, role._id, newRole._id)
        } else if (role.type === ROLE_TYPE.COMPANY) {
          await memberClient.migrateCompanyRoleMembers(companyId, role._id, newRole._id)
        }
        newRoles.push(newRole)
      }
    } catch (e) {
      console.error(LOG_NS, e)
    }
  }

  scopes = await roleScopeClient.getAllCompanyScopes(companyId)
  await roleScopeClient.updateRoleScopeAudit(audit._id, 'final', scopes)

  return newRoles
}

/**
 *
 * @param companyId
 * @returns {Promise<void>}
 */
async function downgradeRoles(companyId) {

  let roles = await getRoles(companyId)

  let scopes = await roleScopeClient.getAllCompanyScopes(companyId)
  let audit = await roleScopeClient.createRoleScopeAudit(companyId, 'downgrade', scopes)

  for (let role of roles) {
    //down grade should still remove custom roles I guess
    if (!role.immutable) {
      if (role.type === ROLE_TYPE.POSITION) {
        await roleScopeClient.migratePositionRoleMembers(companyId, role._id, ROLE.POSITION_MEMBER)
        await roleScopeClient.removePositionRoleScope(companyId, role._id)
      } else if (role.type === ROLE_TYPE.COMPANY) {
        await memberClient.migrateCompanyRoleMembers(companyId, role._id, ROLE.COMPANY_MEMBER)
      }
    }
  }
  scopes = await roleScopeClient.getAllCompanyScopes(companyId)
  await roleScopeClient.updateRoleScopeAudit(audit._id, 'final', scopes)
}

/**
 * Clean and trim the permission list
 * @param dirtyPermissions
 * @returns {[]}
 * @private
 */
function _cleanPermissions(dirtyPermissions) {
  let curated = []
  if (!dirtyPermissions) {
    return curated
  }
  for (let permission of dirtyPermissions) {
    if (permission.access && (permission.access.create || permission.access.read || permission.access.update || permission.access.remove)) {
      curated.push(permission)
    }
  }
  return curated
}