'use strict'

const {MODEL_VERSION, ROLE, ROLE_TYPE, PERMISSION, permissions, PERMISSION_TYPE} = require('../../../data/security-config')
const memberClient = require('../company/core-member')
const roleScopeClient = require('../security/core-role-scope')
const positionClient = require('../position/core-position')
const securityCache = require('../security/core-security-cache')
const companySettingsClient = require('../company/core-company-settings')
const teamClient = require('../company/core-team')
const roleClient = require('../security/core-role')

const {AccessManager, SCOPE_ALL, securityRequirement, mergePermissions} = require('../../security/access-manager')
const LOG_NS = '[CORE-SECURITY]'
const USER_NIMBLEBOT = 'nimblebot'


module.exports = {
  getSecurity,
  getAccessManager,
  buildAccessManager,
  migrateCompanyMember
}


/**
 * gets an instance of the access manager from user and companyids
 * @returns {Promise<AccessManager>}
 * @param company
 * @param user
 */
async function getAccessManager(company, user) {

  let security;

  try {
    security = await getSecurity(company, user);
    return new AccessManager(security)
  } catch (e) {
    console.error(LOG_NS, e)
  }
  let userId = !user ? 'unknown user' : user._id
  let companyId = !company ? 'unknown company' : company._id
  return new AccessManager({userId: userId, companyId: companyId, positionRoles: {}, roles: [], permissions: {}})
}

/**
 * Creates an instance of the access manager based on user and company promises
 * @param {Promise} userPromise
 * @param {Promise} companyPromise
 * @returns {Promise<AccessManager>}
 */
async function buildAccessManager(userPromise, companyPromise) {
  let user = await userPromise
  let company = await companyPromise
  if (user && company) {
    if (typeof company.settings.ats.role_based_security_enabled === 'undefined') {
      await memberClient.migrateCompanyMembersFromCompany(company)
      await positionClient.migratePositionMembers(company._id)
      let settings = {}
      settings['role_based_security_enabled'] = false
      await companySettingsClient.updateCompanySetting(company, settings, USER_NIMBLEBOT)
    }
    let security = await getSecurity(company, user)

    return new AccessManager(security)
  } else {
    let userId = user ? user._id : ''
    let companyId = company ? company._id : ''
    return new AccessManager({userId: userId, companyId: companyId, positionRoles: {}, roles: [], permissions: {}})
  }
}

/**
 * Builds security models using scopes
 * @param company
 * @param user
 * @returns {Promise<{companyId: *, permissions: *, roles: *, positionRoles: *, userId: *, version: *, teamIds: *}|{companyId: *, permissions: {}, roles: [], positionRoles: {}, userId: *, version: *}>}
 */
async function getSecurityPermissions(company, user) {

  let userId = user._id

  // we short circuit for nimblebot
  if (userId === USER_NIMBLEBOT) {
    return {
      userId: userId,
      companyId: company._id,
      roles: [],
      positionRoles: {},
      permissions: {},
      version: MODEL_VERSION
    }
  }

  let member = await memberClient.getCompanyMember(company._id, userId)
  let teamIds = await teamClient.getUserCompanyTeamIds(company._id, userId)
  let positionScopes = await roleScopeClient.getMemberPositions(company._id, userId, teamIds)
  let companyRoles = await roleClient.getCompanyRoles(company)
  let security
  let positionRoles = {}

  if (!member) {
    member = {}
  }
  if (!member.roles) {
    console.warn(LOG_NS, 'User', member._id, 'has no company role defined')
    return {
      userId: userId,
      companyId: company._id,
      roles: [],
      positionRoles: {},
      permissions: {},
      version: MODEL_VERSION
    }
  }

  if (positionScopes) {
    for (let scope of positionScopes) {
      if (scope.role) {
        if (!(scope.role in positionRoles)) {
          positionRoles[scope.role] = []
        }
        if (scope.position_id && positionRoles[scope.role].indexOf(scope.position_id) < 0) {
          positionRoles[scope.role].push(scope.position_id)
        }
      }
    }
  }

  let memberPermissions = {}
  for (let role of companyRoles) {
    if ((member.roles.indexOf(role._id) >= 0) || (role._id in positionRoles)) {
      role = applyAutomaticPermissions(role)
      for (let permission of role.permissions) {
        if (role.type === ROLE_TYPE.POSITION) {
          if (member.roles.indexOf(role._id) < 0) {
            member.roles.push(role._id)
          }
          if (!(role._id in memberPermissions)) {
            memberPermissions[role._id] = {}
          }
          memberPermissions[role._id][permission._id] = securityRequirement(permission.access)
        } else {
          if (permission._id in memberPermissions) {
            memberPermissions[permission._id] = mergePermissions(memberPermissions[permission._id], securityRequirement(permission.access))
          } else {
            memberPermissions[permission._id] = securityRequirement(permission.access)
          }
        }
      }
    }
  }

  //roll up memberPermissions (efficiency)
  for (let key in positionRoles) {
    for (let perm in memberPermissions[key]) {
      if (perm in memberPermissions) {
        if ((memberPermissions[perm] & memberPermissions[key][perm]) === memberPermissions[key][perm]) {
          delete memberPermissions[key][perm]
        }
      }
    }
  }

  security = {
    userId: userId,
    companyId: company._id,
    teamIds: teamIds,
    roles: member.roles,
    positionRoles: positionRoles,
    permissions: memberPermissions,
    version: MODEL_VERSION
  }
  return security
}

/**
 *
 * @param role
 * @returns {*}
 */
function applyAutomaticPermissions(role) {

  let managePositions = false
  let positionAccess = {}
  if (role.type === ROLE_TYPE.COMPANY && !role.immutable) {
    for (let permission of role.permissions) {
      if (permission._id === PERMISSION.POSITION_ACCESS) {
        if (permission.access.update) {
          managePositions = true
          positionAccess = permission.access
          break
        }
      }
    }
  } else if (!role.immutable) {
    let addPositionPermission = true
    for (let permission of role.permissions) {
      if (permission._id === PERMISSION.POSITION_ACCESS) {
        if (permission.access) {
          addPositionPermission = false
          permission.access.read = true
          break
        }
      }
    }
    if (addPositionPermission) {
      role.permissions.push({
        _id: PERMISSION.POSITION_ACCESS,
        access: {read: true}
      })
    }
    role.permissions.push({
      _id: PERMISSION.CANDIDATE_ACCESS,
      access: {read: true}
    })
  }

  if (managePositions) {
    let permissionIds = role.permissions.map(p => p._id)
    for (let permission of permissions) {
      if (permission.type === PERMISSION_TYPE.SCOPED && permissionIds.indexOf(permission._id) === -1) {
        role.permissions.push({
          _id: permission._id,
          access: positionAccess
        })
      }
    }
  }

  return role
}

/**
 * loads/creates security model for a user and company
 * @param company
 * @param user
 * @returns {Promise<*>}
 */
async function getSecurity(company, user) {

  let security = await securityCache.getUserSecurityFromCache(company._id, user._id)
  if (!security || MODEL_VERSION !== security.version) {
    security = await getSecurityPermissions(company, user)
    securityCache.cacheUserSecurity(security)
  }
  return security
}

/**
 * migrateCompanyUser
 * @param {string} userId
 * @param {object} company
 * @returns {Promise<void>}
 */
async function migrateCompanyMember(userId, company) {
  let role
  if (!company || !company.admins || !userId) {
    console.error(LOG_NS, 'Can not migrate user to role', 'for member', userId, 'in company', company._id)
    return
  } else if (company.admins.indexOf(userId) >= 0) {
    if (company.settings.ats.candidate_management_company_admin) {
      role = ROLE.COMPANY_ADMIN
    } else {
      role = ROLE.SYSTEM_ONLY
    }
  } else {
    let member = await memberClient.getCompanyMember(company._id, userId)
    if (member) {
      role = ROLE.COMPANY_MEMBER
    } else {
      console.error(LOG_NS, 'Can not migrate user to role', userId, 'is not a member', 'in company', company._id)
      return
    }
  }
  console.log(LOG_NS, 'Migrating company role', role, 'for member', userId, 'in company', company._id)
  await memberClient.addCompanyRoleToUser(company._id, userId, role)
  return role
}