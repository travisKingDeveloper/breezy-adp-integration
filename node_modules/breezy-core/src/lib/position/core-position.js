'use strict'

const _ = require('lodash')
const mongo = require('../../db/mongoClient')()
const helpers = require('../../util/helpers')
const {getConfig} = require('../../util/breezy-config')
const config = getConfig()
const LOG_NS = '[CORE-POSITION]'
const POSITION_CACHE_KEY = 'BREEZY_POSITION_'
const POSITION_COLLECTION = 'position'
const teamClient = require('../company/core-team')
const memberClient = require('../company/core-member')
const roleScopeClient = require('../security/core-role-scope')
const companyClient = require('../company/core-company')
const positionApprovalClient = require('./core-position-approval')
const securityConfig = require('../../../data/security-config')
const securityCache = require('../security/core-security-cache')


module.exports = {
  getPositionById,
  getPositionWithContext,
  getUserPositionsRole,
  getAllCompanyPositions,
  addMemberToPosition,
  removeMemberFromPosition,
  addTeamToPosition,
  removeTeamFromPosition,
  migratePositionMembers
}

/**
 * Gets a position from cache
 * @param positionId
 * @returns {Promise<any>}
 */
async function getPositionFromCache(positionId) {

  let position = await helpers.cache.chooseCache(positionId).getAsync(POSITION_CACHE_KEY + positionId)
  if (position) {
    return JSON.parse(position)
  }
}

async function invalidatePositionCache(positionId) {
  helpers.cache.chooseCache(positionId).delete(POSITION_CACHE_KEY + positionId, function (error, value) {
  })
}

/**
 * Gets a position from the DB
 * @param criteria
 * @returns {Promise<*>}
 */
async function getPosition(criteria) {

  try {
    return mongo.getDocumentAsync({
      collection: POSITION_COLLECTION,
      criteria: criteria
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 * gets a position by Id
 * @param {string} positionId
 * @returns {Promise<*>}
 */
async function getPositionById(positionId) {

  let cache = await getPositionFromCache(positionId)
  if (cache) {
    return cache
  }

  let position = await getPosition({_id: positionId})

  if (position) {
    position.teams = helpers.initializePositionTeams(position)
    helpers.cache.chooseCache(positionId).set(POSITION_CACHE_KEY + positionId, JSON.stringify(position), 43200, function (error, value) {
    })
  }

  return position
}

/**
 * gets a position by Id, can optionally apply company and/or user context data
 * @param {string} positionId
 * @param {object} [actingUser]
 * @param {object} [company]
 * @param {object} [security]
 * @returns {Promise<*>}
 */
async function getPositionWithContext(positionId, actingUser, company, security) {

  let position = await getPositionById(positionId)

  if (!position) {
    return position
  }

  //Company specific post processing if a Company is supplied
  if (company) {
    position.company = await company

    if (!position.social_discovery) {
      position.social_discovery = position.company.settings.ats.social_discovery
    }

    let members = await getAllPositionMemberIds(position, company)
    if (members) {
      position.all_users = members.all_users
      position.all_admins = members.all_admins
      position.teams = members.teams
    }
  }

  //User specific post processing if a user is supplied
  if (actingUser) {
    actingUser = await actingUser
  }

  //Post processing that requires both a user and a company
  if (actingUser && company) {

    helpers.postProcessUserPosition(position, company, actingUser, security)

    if (position.is_pending || position.pending_approval) {
      position = setPositionApprovalDetail(company, position, actingUser)
    }
  }
  return position
}

/**
 * Gets a team
 * @param company
 * @param teamId
 * @returns {Promise<any>}
 */
async function getTeam(company, teamId) {

  if (teamId === teamClient.ALL_MEMBERS) {
    let members = await companyClient.getCompanyMembers(company)
    let defaultTeam = JSON.parse(JSON.stringify(config.DefaultAllMembersTeam))
    for (let member of members) {
      defaultTeam.member_ids.push(member._id)
    }
    return defaultTeam
  } else {
    return await teamClient.getCompanyTeamById(company._id, teamId)
  }
}

/**
 *
 * @param position
 * @param company
 * @returns {Promise<{all_users: *, all_admins: *}>}
 */
async function getAllPositionMemberIds(position, company) {

  let userIds = position.users || []
  let adminIds = position.admins || []
  let teams = {}

  let positionScopes = await roleScopeClient.getPositionMembers(company._id, position._id)
  for (let scope of positionScopes) {
    if (scope.teams) {
      teams[scope.role] = []
      for (let teamId of scope.teams) {
        let team = await getTeam(company, teamId)
        if (team) {
          teams[scope.role].push(teamId)
          userIds = userIds.concat(team.member_ids)
          if (scope.role === securityConfig.ROLE.HIRING_MANAGER) {
            adminIds = adminIds.concat(team.member_ids)
          }
        }
      }
    }
  }
  return {
    all_users: _.uniq(userIds),
    all_admins: _.uniq(adminIds),
    teams: teams
  }
}

// async function getIndividualPositionMembers(company, position, actingUser) {
//
//   let memberRoleIds = {}
//   let members = []
//
//   let positionScopes = await roleScopeClient.getPositionMembers(company._id, position._id)
//   for (let scope of positionScopes) {
//     if (scope.members) {
//       memberRoleIds[scope.role] = []
//       for (let memberId of scope.members) {
//         let member
//         for (let existingMember of members) {
//
//         }
//         member = await memberClient.getCompanyMember(company._id, memberId)
//         if (member) {
//           memberRoleIds[scope.role].push(memberId)
//           member.roles = helpers.getUserRoleFromPosition(position, member);
//           member.is_assignable = helpers.userIsAssignable(member)
//           if (member.roles && member.roles.length > 0) {
//             members.push(member);
//           }
//         }
//       }
//     }
//   }
//   return members
// }

/**
 * setPositionApprovalDetail
 * @param company
 * @param position
 * @param actingUser
 * @returns {Promise<*>}
 */
async function setPositionApprovalDetail(company, position, actingUser) {

  let approval
  try {
    approval = await positionApprovalClient.getPendingPositionApproval({
      companyId: company._id,
      positionId: position._id
    })
    position.pending_approval = approval
  } catch (e) {
    console.error(LOG_NS, e)
    return position
  }

  try {
    position.is_reviewable = await positionApprovalClient.isPositionApprovalReviewable({
      approval: approval,
      actingUser: actingUser
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }

  return position
}

/**
 * Gets user positions for security ( this goes away in phase 2 )
 * @param company
 * @param teamIds
 * @param state
 * @param unarchivedIdsOnly
 * @param actingUser
 * @returns {Promise<void>}
 */
async function getUserPositionsRole(company, teamIds, state, unarchivedIdsOnly, actingUser) {

  if (!teamIds) teamIds = []

  let criteria = {'company_id': company._id}
  let project = {}

  project._id = 1
  project.admins = 1
  project.users = 1
  project.teams = 1

  criteria['$or'] = [
    {'users': {$in: [actingUser._id]}}
  ]
  if (teamIds.length > 0) {
    criteria['$or'].push({'teams.admin': {$in: teamIds}})
    criteria['$or'].push({'teams.member': {$in: teamIds}})
  }

  let positions = await mongo.getDocumentsAsync({
    collection: 'position',
    criteria: criteria,
    project: project,
    limit: config.position_query_limit
  })

  if (!positions) {
    throw new Error('Problem getting positions')
  }

  if (!unarchivedIdsOnly) {
    for (let i = 0; i < positions.length; i++) {
      let position = positions[i]
      position.company = company
    }
  }
  return positions
}

/**
 * Gotta Collect em all... no criteria, just everything
 * @param companyId
 * @returns {Promise<*>}
 */
async function getAllCompanyPositions(companyId) {

  let criteria = {'company_id': companyId}
  let project = {}

  project._id = 1
  project.admins = 1
  project.users = 1
  project.teams = 1
  project.creator_id = 1

  let positions = await mongo.getDocumentsAsync({
    collection: 'position',
    criteria: criteria,
    project: project,
    limit: config.position_query_limit
  })

  if (!positions) {
    throw new Error('Problem getting positions')
  }

  return positions
}

/***********************************************************************************************************************
 * Maintain legacy counts on positions
 * these calls will wrap the new scope generation
 **********************************************************************************************************************/

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} userId
 * @param {string} role
 * @returns {Promise<void>}
 */
async function addMemberToPosition(companyId, positionId, userId, role) {

  let updates

  if (role) {
    if (role === securityConfig.ROLE.HIRING_MANAGER) {
      updates = {$addToSet: {admins: userId}}
    } else {
      updates = {$addToSet: {users: userId}}
    }
    await updatePosition(
      {_id: positionId, company_id: companyId},
      updates,
      {upsert: true})
    await invalidatePositionCache(positionId)
    await roleScopeClient.addMemberToPosition(companyId, positionId, userId, role)
  }
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} teamId
 * @param {string} role
 * @returns {Promise<void>}
 */
async function addTeamToPosition(companyId, positionId, teamId, role) {

  let updates

  if (role) {
    if (role === securityConfig.ROLE.HIRING_MANAGER) {
      updates = {$addToSet: {'teams.admin': teamId}}
    } else {
      updates = {$addToSet: {'teams.member': teamId}}
    }
    await updatePosition(
      {company_id: companyId, _id: positionId},
      updates,
      {upsert: true})
    await roleScopeClient.addTeamToPosition(companyId, positionId, teamId, role)
  } else {
    await updatePosition(
      {company_id: companyId, _id: positionId, role: role},
      {teams: {$addToSet: {member: teamId}}},
      {upsert: true})
  }
  await invalidatePositionCache(positionId)
}

/**
 *
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} userId
 * @param {string} [role]
 * @returns {Promise<void>}
 */
async function removeMemberFromPosition(companyId, positionId, userId, role) {

  let updates

  if (role) {

    if (await roleScopeClient.canRemoveMember(companyId, positionId, role)) {

      if (role === securityConfig.ROLE.HIRING_MANAGER) {
        updates = {$pull: {admins: userId}}
      } else {
        updates = {$pull: {users: userId}}
      }

      await updatePosition(
        {_id: positionId, company_id: companyId},
        updates)

    }
  } else {

    await updatePosition(
      {company_id: companyId, _id: positionId},
      {$pull: {admins: userId, users: userId}})

  }
  await invalidatePositionCache(positionId)
  await roleScopeClient.removeMemberFromPosition(companyId, positionId, userId, role)
}

/**
 * Remove a team from position, specifying a role will remove the team only from that role on a position
 * @param {string} companyId
 * @param {string} positionId
 * @param {string} teamId
 * @param {string} [role]
 * @returns {Promise<void>}
 */
async function removeTeamFromPosition(companyId, positionId, teamId, role) {

  let updates

  if (role) {

    if (await roleScopeClient.canRemoveMember(companyId, positionId, role)) {

      if (role === securityConfig.ROLE.HIRING_MANAGER) {
        updates = {$pull: {'teams.admin': teamId}}
        //updates = {teams: {$pull: {admin: teamId}}}
      } else {
        updates = {$pull: {'teams.member': teamId}}
        //updates = {teams: {$pull: {member: teamId}}}
      }

      await updatePosition(
        {_id: positionId, company_id: companyId},
        updates)

    }
  } else {

    await updatePosition(
      {company_id: companyId, _id: positionId},
      {$pull: {'teams.admin': teamId, 'teams.member': teamId}})

  }
  await invalidatePositionCache(positionId)
  await roleScopeClient.removeTeamFromPosition(companyId, positionId, teamId, role)
}

/**
 *
 * @param {object} criteria
 * @param {object} updates
 * @param {object} [options]
 * @returns {Promise<void>}
 */
async function updatePosition(criteria, updates, options = {}) {

  try {
    return await mongo.updateDocumentAsync({
      collection: POSITION_COLLECTION,
      criteria: criteria,
      updates: updates,
      options: options
    })
  } catch (e) {
    console.error(LOG_NS, e)
  }
}

/**
 * Migrate company position members
 * @param companyId
 * @returns {Promise<void>}
 */
async function migratePositionMembers(companyId) {
  console.log(LOG_NS, 'Migrating position member data for company', companyId)

  let memberIds = []
  let teamIds = []

  let members = await memberClient.getMembersByCompanyId(companyId)
  if (members) {
    memberIds = members.map(m => m.user_id)
  }

  let teams = await teamClient.getCompanyTeams(companyId)
  if (teams) {
    teamIds = teams.map(t => t._id)
  }
  teamIds.push(teamClient.ALL_MEMBERS)

  let positions = await getAllCompanyPositions(companyId)

  for (let position of positions) {

    console.log('Company', companyId, 'Migrating Position', position._id)

    //migrate the creator
    if (memberIds.indexOf(position.creator_id) > -1) {
      await roleScopeClient.addMemberToPosition(companyId, position._id, position.creator_id, securityConfig.ROLE.HIRING_MANAGER)
    }

    //migrate HMs
    for (let hiringManagerId of position.admins) {
      if (memberIds.indexOf(hiringManagerId) > -1) {
        await roleScopeClient.addMemberToPosition(companyId, position._id, hiringManagerId, securityConfig.ROLE.HIRING_MANAGER)
      }
    }

    //migrate Members
    for (let memberId of position.users) {
      if (position.admins && memberIds.indexOf(memberId) > -1 && position.admins.indexOf(memberId) < 0) {
        await roleScopeClient.addMemberToPosition(companyId, position._id, memberId, securityConfig.ROLE.POSITION_MEMBER)
      }
    }

    //migrate HM teams
    if (position.teams && position.teams.admin) {
      for (let hiringManagerTeamId of position.teams.admin) {
        if (teamIds.indexOf(hiringManagerTeamId) > -1) {
          await roleScopeClient.addTeamToPosition(companyId, position._id, hiringManagerTeamId, securityConfig.ROLE.HIRING_MANAGER)
        }
      }
    }

    //migrate member teams
    if (position.teams && position.teams.member) {
      for (let positionMemberTeamId of position.teams.member) {
        if (teamIds.indexOf(positionMemberTeamId) > -1) {
          await roleScopeClient.addTeamToPosition(companyId, position._id, positionMemberTeamId, securityConfig.ROLE.POSITION_MEMBER)
        }
      }
    }

    for (let id of memberIds) {
      securityCache.invalidateCache(companyId, id)
    }
  }
}