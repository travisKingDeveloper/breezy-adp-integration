'use strict'

const {MongoClient} = require('mongodb')
const {MongoError, ValidationError} = require('../system/error')
const LOG_NS = '[MONGO]'
const MONGO_CONNECT = 'nope'
// mongodb://localhost:27017/NIMBLE'
const DB_NAME = 'NIMBLE'
const VALIDATION_MISSING_ELEMENT = 'Required element missing'
const MONGO_ERROR_INSERT = 'Error inserting a document'
const MONGO_ERROR_UPDATE = 'Error updating a document'
const MONGO_ERROR_DELETE = 'Error deleting a document'
const MONGO_ERROR_GET = 'Error retrieving a document'
const MONGO_ERROR_COLLECTION = 'Error getting a collection'

class Mongo {

  constructor() {
    this._db = null
    this._client = null
  }

  /**
   * On demand init since we can't await in a constructor
   * @returns {Promise<null>}
   */
  async init() {
    console.log(LOG_NS, 'Initializing Mongo Instance')
    if (!this._db) {
      this._client = new MongoClient(MONGO_CONNECT, {useNewUrlParser: true})
      await this._client.connect()
      this._db = this._client.db(DB_NAME)
    }
    return this._db
  }

  /**
   * Returns a mongo collection
   * @param {string} name
   * @returns {Collection}
   */
  async getCollection(name) {
    if (!this._db) {
      await this.init()
    }
    return await this._db.collection(name)
  }

  /**
   * takes a document from the user and puts it in the collection
   * @param collection
   * @param doc
   * @param options
   * @returns {Promise<*>}
   */
  async putDocument({collection, doc, options}) {
    if (!collection) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'collection')
    if (!doc) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'doc')
    if (!options) options = {}

    let mongoCollection;
    try {
      mongoCollection = await this.getCollection(collection);
    } catch (e) {
      throw new MongoError(MONGO_ERROR_COLLECTION, e)
    }

    let objs

    try {
      objs = await mongoCollection.insertOne(doc, options)
    } catch (e) {
      throw new MongoError(MONGO_ERROR_INSERT, e)
    }

    if (!objs || !objs.ops || !Array.isArray(objs.ops)) {
      throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'result');
    }

    return objs.ops[0]
  }

  /**
   * gets a single document by criteria
   * @param collection
   * @param criteria
   * @param options
   * @returns {Promise<*>}
   */
  async getDocument({collection, criteria, options}) {
    if (!collection) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'collection')
    if (!criteria) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'criteria')
    if (!options) options = {}

    let mongoCollection;
    try {
      mongoCollection = await this.getCollection(collection);
    } catch (e) {
      console.error(LOG_NS, `Error getting collection ${collection}`, e)
      throw new MongoError(MONGO_ERROR_COLLECTION, e)
    }
    let obj

    try {
      obj = await mongoCollection.findOne(criteria, options)
    } catch (e) {
      console.error(LOG_NS, e)
      throw new MongoError(MONGO_ERROR_GET, e)
    }

    return obj
  }

  /**
   * Gets multiple documents by criteria
   * @param collection
   * @param criteria
   * @param sort
   * @param limit
   * @param skip
   * @param project
   * @returns {Promise<Array|*>}
   */
  async getDocuments({collection, criteria, sort, limit, skip, project}) {
    if (!collection) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'collection')
    if (!criteria) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'criteria')
    if (!sort) sort = {}
    if (!skip) skip = 0
    if (!limit) limit = 200
    if (!project) project = {}

    let mongoCollection;
    try {
      mongoCollection = await this.getCollection(collection);
    } catch (e) {
      throw new MongoError(MONGO_ERROR_COLLECTION, e)
    }

    let cursor = mongoCollection.find(criteria)

    cursor
      .project(project)
      .limit(limit)
      .skip(skip)
      .sort(sort)

    let objs

    try {
      objs = await cursor.toArray()
    } catch (e) {
      throw new MongoError(MONGO_ERROR_GET, e)
    }
    if (!objs) objs = []
    cursor.close()

    return objs
  }


  /**
   * find a doc... then update it
   * @param collection
   * @param criteria
   * @param u
   * @param options
   * @param manualSet
   * @returns {Promise<*>}
   */
  async findOneAndUpdate({collection, criteria, updates: u, options, manualSet}) {
    // NOTE: make a copy of updates param since we will be making changes to the object
    let updates = _.cloneDeep(u)

    if (!collection) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'collection')
    if (!criteria) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'criteria')
    if (!updates) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'updates')
    if (!options) options = {}

    options.returnOriginal = false

    if (updates._id) delete updates._id

    if (!manualSet) {
      // default behavior is to use $set to prevent accidentally overwriting data
      updates = {$set: updates}
    }

    let mongoCollection;
    try {
      mongoCollection = await this.getCollection(collection);
    } catch (e) {
      throw new MongoError(MONGO_ERROR_COLLECTION, e)
    }
    let obj

    try {
      obj = await mongoCollection.findOneAndUpdate(criteria, updates, options)
    } catch (e) {
      throw new MongoError(MONGO_ERROR_UPDATE)
    }

    return obj.value
  }


  /**
   * deletes a document
   * @param collection
   * @param criteria
   * @returns {Promise<*>}
   */
  async deleteDocument({collection, criteria}) {
    if (!collection) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'collection')
    if (!criteria) throw new ValidationError(VALIDATION_MISSING_ELEMENT, 'criteria')

    let mongoCollection;
    try {
      mongoCollection = await this.getCollection(collection);
    } catch (e) {
      throw new MongoError(MONGO_ERROR_COLLECTION, e)
    }
    let result = null

    try {
      result = await mongoCollection.deleteOne(criteria)
    } catch (e) {
      console.error(LOG_NS, `Error: deleteDocument ${error.message}`)
      throw new MongoError(MONGO_ERROR_DELETE, e)
    }

    return result
  }

  /**
   * Clean up... go home...
   */
  close() {
    console.log(LOG_NS, "Shutting down...")
    if (this._client) {
      return this._client.close()
    }
  }
}

const _instance = new Mongo()
_instance.init()

module.exports = _instance