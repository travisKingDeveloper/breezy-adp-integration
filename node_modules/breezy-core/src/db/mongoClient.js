'use strict'

const {MongoClient} = require('mongodb')
const _ = require('lodash')
const {getConfig} = require('../util/breezy-config')
const helpers = require('../util/helpers')
const mongoConstants = require('./mongo_constants')
const config = getConfig()
const mongoConfigUs = config.Mongo.connectionString
const mongoConfigEu = config.Mongo_EU.connectionString
const DB_NAME = 'NIMBLE'

let mongoClientUs, mongoClientEu
let mongo

module.exports = function () {

  // if connection already established, return it
  if (mongo) {
    //console.log('[MONGO] - Re-using existing connection.');
    return mongo;
  }

  // else - connect and create mongo interface
  mongo = {};

  //, useUnifiedTopology: true when we're ready
  let usClient = new MongoClient(mongoConfigUs, {useNewUrlParser: true, useUnifiedTopology: true})
  let euClient = new MongoClient(mongoConfigEu, {useNewUrlParser: true, useUnifiedTopology: true})
  // connect to mongo
  console.log('[MONGO] - Initializing mongo...');
  Promise.all([
    usClient.connect(),
    euClient.connect()
  ]).then(function (results) {
    console.log("connected to: " + mongoConfigUs);
    console.log("connected to: " + mongoConfigEu);
    mongoClientUs = results[0].db(DB_NAME);
    mongoClientEu = results[1].db(DB_NAME);
  }).catch(function (error) {
    console.error('[MONGO] - Problem connecting to MongoDB');
    console.error(error);
    throw error;
  });

  // data{collection, criteria}
  mongo.countDocuments = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    let mc = chooseMongoClient(data.collection, data.criteria),
      collection = mc.collection("BP_" + data.collection);

    collection.count(data.criteria, function (error, count) {
      if (error) console.error('Mongo Error: ' + error.message);
      if (!count) count = 0;

      return callback(error, count);
    });
  };

  /**
   *
   * @param {collection, criteria} data
   * @returns {Promise}
   */
  mongo.countDocumentsAsync = async function (data) {
    return new Promise((resolve, reject) => {
      if (!data.collection) throw new Error('collection is not defined');
      if (!data.criteria) throw new Error('criteria is not defined');

      let mc = chooseMongoClient(data.collection, data.criteria),
        collection = mc.collection("BP_" + data.collection);

      collection.count(data.criteria, function (error, count) {
        if (error) console.error('Mongo Error: ' + error.message);
        if (!count) count = 0;

        return resolve(count);
      });
    });
  }

  // data{collection, doc, options}
  mongo.putDocument = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.doc) return callback(new Error('doc is not defined'));

    if (!data.options) data.options = {};

    let mc = chooseMongoClient(data.collection, data.doc),
      collection = mc.collection("BP_" + data.collection);

    collection.insert(data.doc, data.options, function (error, objs) {
      if (error) console.error('Mongo Error: ' + error.message);

      if (objs && objs.ops && Array.isArray(objs.ops)) {
        return callback(error, objs.ops[0]);
      }
      return callback(error);
    });
  };

  /**
   *
   * @param {collection, doc, options} data
   * @returns {Promise}
   */
  mongo.putDocumentAsync = function (data) {
    return new Promise((resolve, reject) => {

      if (!data.collection) return reject(new Error('collection is not defined'));
      if (!data.doc) return reject(new Error('doc is not defined'));

      if (!data.options) data.options = {};

      let mc = chooseMongoClient(data.collection, data.doc),
        collection = mc.collection("BP_" + data.collection);

      collection.insert(data.doc, data.options, function (error, objs) {
        if (error) console.error('Mongo Error: ' + error.message);

        if (objs && objs.ops && Array.isArray(objs.ops)) {
          return resolve(objs.ops[0]);
        }
        return reject(error);
      });
    })
  };


  // data{collection, criteria, updates, options, manualSet?}
  // data.manualSet - dont use $set for updates
  mongo.findAndModify = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.updates) return callback(new Error('updates is not defined'));

    if (!data.options) data.options = {};

    let mc = chooseMongoClient(data.collection, data.criteria),
      collection = mc.collection("BP_" + data.collection);

    if (data.updates._id) delete data.updates._id;
    data.options.new = true;

    let updates = {$set: data.updates};

    if (data.manualSet) {
      updates = data.updates;
    }

    collection.findAndModify(
      data.criteria,
      [['_id', 'asc']],
      updates,
      data.options,
      function (error, matchedGroup) {
        if (error) console.error('Mongo Error: ' + error.message);
        return callback(error, matchedGroup.value);
      }
    );
  };

  // data{collection, criteria, updates, options, manualSet?}
  // data.manualSet - dont use $set for updates
  /**
   *
   * @param {collection, criteria, updates, options, manualSet?} data
   * @returns {Promise}
   */
  mongo.findAndModifyAsync = function (data) {
    return new Promise((resolve, reject) => {
      if (!data.collection) return reject(new Error('collection is not defined'));
      if (!data.criteria) return reject(new Error('criteria is not defined'));
      if (!data.updates) return reject(new Error('updates is not defined'));

      if (!data.options) data.options = {};

      let mc = chooseMongoClient(data.collection, data.criteria),
        collection = mc.collection("BP_" + data.collection);

      if (data.updates._id) delete data.updates._id;
      data.options.new = true;

      let updates = {$set: data.updates};

      if (data.manualSet) {
        updates = data.updates;
      }

      collection.findAndModify(
        data.criteria,
        [['_id', 'asc']],
        updates,
        data.options
      ).then(function (matchedGroup) {
        return resolve(matchedGroup.value)
      })
    })
  };

  // data{collection, criteria, updates}
  mongo.findAndModifyWithFallback = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.updates) return callback(new Error('updates is not defined'));

    if (!data.options) data.options = {};

    let mcUs = mongoClientUs,
      mcEu = mongoClientEu,
      collectionUs = mcUs.collection("BP_" + data.collection),
      collectionEu = mcEu.collection("BP_" + data.collection);

    if (data.updates._id) delete data.updates._id;
    data.options.new = true;

    console.log("[MONGO] - find and modify with fallback");
    collectionUs.findAndModify(
      data.criteria,
      [['_id', 'asc']],
      {$set: data.updates},
      data.options,
      function (error, matchedGroup) {
        if (error) console.error('Mongo Error: ' + error.message);

        if (matchedGroup && matchedGroup.value) {
          return callback(error, matchedGroup.value);
        }
        console.log("[MONGO] - not found in us, checking eu");
        collectionEu.findAndModify(
          data.criteria,
          [['_id', 'asc']],
          {$set: data.updates},
          {'new': true},
          function (error, matchedGroup) {
            if (error) console.error('Mongo Error: ' + error.message);
            return callback(error, matchedGroup.value);
          }
        );
      }
    );
  };

  /**
   *
   * @param {collection, criteria, updates} data
   * @returns {Promise<Promise|*>}
   */
  mongo.findAndModifyWithFallbackAsync = async function (data) {
    if (!data.collection) throw new Error('collection is not defined');
    if (!data.criteria) throw new Error('criteria is not defined');
    if (!data.updates) throw new Error('updates is not defined');
    if (!data.options) data.options = {};

    if (data.updates._id) delete data.updates._id;
    data.options.new = true;

    let mcUs = mongoClientUs
    let collectionUs = mcUs.collection("BP_" + data.collection)

    let usResult = await new Promise((resolve, reject) => {
      try {
        let matchedGroup = collectionUs.findAndModify(
          data.criteria,
          [['_id', 'asc']],
          {$set: data.updates},
          data.options)
        resolve(matchedGroup)
      } catch (e) {
        reject(e)
      }
    })

    if (usResult && usResult.value) {
      return usResult.value;
    }
    console.log("[MONGO]    - not found in us, checking eu");

    let euResult = await new Promise((resolve, reject) => {
      let mcEu = mongoClientEu
      let collectionEu = mcEu.collection("BP_" + data.collection);

      console.log("[MONGO] - not found in us, checking eu");
      let matchedGroup = collectionEu.findAndModify(
        data.criteria,
        [['_id', 'asc']],
        {$set: data.updates},
        data.options
      );
      return resolve(matchedGroup);
    })
    if (euResult) {
      return euResult.value
    }
    return
  };

  // data{collection, criteria, updates, options}
  mongo.updateDocument = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.updates) return callback(new Error('updates is not defined'));

    if (!data.options) data.options = {};

    let mc = chooseMongoClient(data.collection, data.criteria),
      collection = mc.collection("BP_" + data.collection);

    if (data.updates._id) delete data.updates._id;

    collection.update(
      data.criteria,
      data.updates,
      data.options,
      function (error, result) {
        if (error) console.error('Mongo Error: ' + error.message);
        return callback(error, result);
      }
    );
  };

  /**
   *
   * @param {collection, criteria, updates, options} data
   * @returns {Promise}
   */
  mongo.updateDocumentAsync = function (data) {
    return new Promise((resolve, reject) => {
      if (!data.collection) return reject(new Error('collection is not defined'));
      if (!data.criteria) return reject(new Error('criteria is not defined'));
      if (!data.updates) return reject(new Error('updates is not defined'));

      if (!data.options) data.options = {};

      let mc = chooseMongoClient(data.collection, data.criteria),
        collection = mc.collection("BP_" + data.collection);

      if (data.updates._id) delete data.updates._id;

      let result = collection.update(
        data.criteria,
        data.updates,
        data.options
      );
      return resolve(result)
    })
  };

  /**
   * Gets a document using callbacks
   * @deprecated
   * @type {MongoObject} data
   * @param callback
   * @returns {*}
   */
  mongo.getDocument = async function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    if (!data.options) data.options = {};

    let mc = chooseMongoClient(data.collection, data.criteria),
      collection = mc.collection("BP_" + data.collection);

    collection.findOne(data.criteria, data.options, function (error, obj) {
      if (error) console.error('Error: getDocument ' + error.message);
      return callback(error, obj);
    });
  };

  /**
   * Gets a document using promises
   * @param {MongoObject} data
   * @returns {*}
   */
  mongo.getDocumentAsync = async function (data) {
    return new Promise((resolve, reject) => {
      if (!data.collection) return reject(new Error('collection is not defined'));
      if (!data.criteria) return reject(new Error('criteria is not defined'));

      if (!data.options) data.options = {};

      let mc = chooseMongoClient(data.collection, data.criteria)
      let collection = mc.collection("BP_" + data.collection);

      let result = collection.findOne(data.criteria, data.options);
      resolve(result);
    })
  };

  // data{collection, criteria, options}
  mongo.getDocumentWithFallback = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    if (!data.options) data.options = {};

    let mcUs = mongoClientUs,
      mcEu = mongoClientEu,
      collectionUs = mcUs.collection("BP_" + data.collection),
      collectionEu = mcEu.collection("BP_" + data.collection);

    console.log("[MONGO] - getting doc with fallback");
    collectionUs.findOne(data.criteria, data.options, function (error, obj) {
      if (error) {
        console.error('Error: getDocument ' + error.message);
        return callback(error);
      }
      if (obj) return callback(error, obj);

      console.log("[MONGO] - not found in us, checking eu");
      collectionEu.findOne(data.criteria, data.options, function (error, obj) {
        if (error) {
          console.error('Error: getDocument ' + error.message);
          return callback(error);
        }
        if (obj) return callback(error, obj);
        return callback();
      });
    });
  };

  // data{collection, criteria, options}
  /**
   *
   * @param {collection, criteria, options} data
   * @returns {Promise}
   */
  mongo.getDocumentWithFallbackAsync = async function (data) {
    if (!data.collection) throw new Error('collection is not defined');
    if (!data.criteria) throw new Error('criteria is not defined');

    if (!data.options) data.options = {};

    let mcUs = mongoClientUs;
    let collectionUs = mcUs.collection("BP_" + data.collection);

    console.log("[MONGO] - getting doc with fallback");

    let result = await new Promise((resolve, reject) => {

      try {
        let obj = collectionUs.findOne(data.criteria, data.options)
        resolve(obj)
      } catch (e) {
        reject(e)
      }
    })

    if (result) return result

    console.log("[MONGO] - not found in us, checking eu")

    return new Promise((resolve, reject) => {

      let mcEu = mongoClientEu;
      let collectionEu = mcEu.collection("BP_" + data.collection);

      try {
        let obj = collectionEu.findOne(data.criteria, data.options)
        resolve(obj)
      } catch (e) {
        reject(e)
      }
    })
  };

  // data{collection, criteria, sort, limit, skip, project}
  mongo.getDocuments = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.limit) data.limit = 200;
    if (!data.project) data.project = {};

    let mc = chooseMongoClient(data.collection, data.criteria);
    try {
      let collection = mc.collection("BP_" + data.collection),
        cursor = collection.find(data.criteria);

      if(data.hint && config.env === "production") { cursor.hint(data.hint) } // force index if passed in ... do not do this everywhere please
      cursor.project(data.project).limit(data.limit).skip(data.skip).sort(data.sort);
      cursor.toArray(function (error, objs) {
        if (error) console.error('Error: getDocuments ' + error.message);
        if (!objs) objs = [];

        return callback(error, objs);
      });
    } catch (e) {
      console.error(e);
    }
  };

  /**
   *
   * @param {collection, criteria, sort, limit, skip, project} data
   * @returns {Promise<*>}
   */
  mongo.getDocumentsAsync = async function (data) {
    if (!data.collection) throw new Error('collection is not defined');
    if (!data.criteria) throw new Error('criteria is not defined');

    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.limit) data.limit = 200;
    if (!data.project) data.project = {};

    let mc = chooseMongoClient(data.collection, data.criteria);
    try {
      let collection = mc.collection("BP_" + data.collection),
        cursor = collection.find(data.criteria);

      if(data.hint && config.env === "production") { cursor.hint(data.hint) } // force index if passed in ... do not do this everywhere please
      cursor.project(data.project).limit(data.limit).skip(data.skip).sort(data.sort);
      let result = await cursor.toArray();
      if (!result) result = [];
      return result
    } catch (e) {
      console.error(e);
    }
  };

  // data{collection, criteria, sort, limit, skip, project}
  mongo.getDocumentsWithTotalCount = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.limit) data.limit = 200;
    if (!data.project) data.project = {};
    let mc = chooseMongoClient(data.collection, data.criteria);
    try {
      let collection = mc.collection("BP_" + data.collection),
        cursor = collection.find(data.criteria);
      cursor.count(function (e, count) {
        if(data.hint && config.env === "production") { cursor.hint(data.hint) } // force index if passed in ... do not do this everywhere please
        cursor.project(data.project)
        cursor.limit(data.limit)
        cursor.skip(data.skip)
        cursor.sort(data.sort);
        cursor.toArray(function (error, objs) {
          if (error) console.error('Error: getDocuments ' + error.message);
          if (!objs) objs = [];
          return callback(null, {total: count, data: objs});
        });
      });

    } catch (e) {
      console.error(e);
    }
  };

  // data{collection, criteria, project, sort, limit, skip, sortKey, sortDir}
  mongo.getDocumentsWithMergeAndTotalCount = function (data, callback) {
    /* USE THIS ON SMALLER COLLECTIONS - cannot reliably page without getting all the data.*/
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.sortKey) return callback(new Error('sortKey is not defined'));
    if (!data.sortDir) return callback(new Error('sortDir is not defined'));

    if (!data.limit) data.limit = 200;
    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.project) data.project = {};

    let mc_us = mongoClientUs,
      mc_eu = mongoClientEu,
      retObj = [],
      count = 0;

    try {
      console.log("[MONGO] - getting documents from US db");
      let collection_us = mc_us.collection("BP_" + data.collection),
        cursor_us = collection_us.find(data.criteria);

      cursor_us.count(function (e, us_count) {
        count += us_count;
        cursor_us.project(data.project);
        cursor_us.sort(data.sort);
        //cursor_us.limit(data.limit);
        //cursor_us.skip(data.skip);
        cursor_us.toArray(function (error, objs) {
          if (error) console.error('Error: getDocuments ' + error.message);
          if (objs) retObj = objs;

          if (config.Mongo.connectionString != config.Mongo_EU.connectionString) {
            console.log("[MONGO] - getting documents from EU db");
            let collection_eu = mc_eu.collection("BP_" + data.collection),
              cursor_eu = collection_eu.find(data.criteria);
            cursor_eu.count(function (e, eu_count) {
              count += eu_count;
              cursor_eu.project(data.project);
              cursor_eu.sort(data.sort);
              //cursor_eu.limit(data.limit);
              //cursor_eu.skip(data.skip);

              cursor_eu.toArray(function (error, objs) {
                if (error) console.error('Error: getDocuments ' + error.message);
                if (objs) {
                  console.log("[MONGO] - merging documents from US and EU dbs");
                  retObj = retObj.concat(objs);
                }
                retObj = helpers.sortNestedObjectArrayByKey(retObj, data.sortKey, data.sortDir);
                retObj = _.chunk(retObj, data.limit)[parseInt(data.skip / data.limit)];
                return callback(error, {total: count, data: retObj});
              });
            });
          } else {
            console.log("[MONGO] - db connection strings are the same, not merging data");
            return callback(error, {total: count, data: retObj});
          }
        });
      });
    } catch (e) {
      console.error(e);
    }
  };

  // data{collection, criteria, sort, limit, skip, project}
  mongo.getDocumentsWithMerge = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.sortKey) return callback(new Error('sortKey is not defined'));
    if (!data.sortDir) return callback(new Error('sortDir is not defined'));

    if (!data.limit) data.limit = 200;
    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.project) data.project = {};

    let mc_us = mongoClientUs,
      mc_eu = mongoClientEu,
      retObj = [];

    try {
      console.log("[MONGO] - getting documents from US db");
      let collection_us = mc_us.collection("BP_" + data.collection),
        cursor_us = collection_us.find(data.criteria);

      cursor_us.project(data.project);
      cursor_us.sort(data.sort);
      cursor_us.limit(data.limit);
      cursor_us.skip(data.skip);
      cursor_us.toArray(function (error, objs) {
        if (error) console.error('Error: getDocuments ' + error.message);
        if (objs) retObj = objs;

        if (config.Mongo.connectionString !== config.Mongo_EU.connectionString) {
          console.log("[MONGO] - getting documents from EU db");
          let collection_eu = mc_eu.collection("BP_" + data.collection),
            cursor_eu = collection_eu.find(data.criteria);

          cursor_eu.project(data.project);
          cursor_eu.sort(data.sort);
          cursor_eu.limit(data.limit);
          cursor_eu.skip(data.skip);
          cursor_eu.toArray(function (error, objs) {
            if (error) console.error('Error: getDocuments ' + error.message);
            if (objs) {
              console.log("[MONGO] - merging documents from US and EU dbs");
              retObj = retObj.concat(objs);
            }
            return callback(error, _.take(helpers.sortObjectArrayByKey(retObj, data.sortKey, data.sortDir), data.limit));
          });
        } else {
          console.log("[MONGO] - db connection strings are the same, not merging data");
          return callback(error, helpers.sortObjectArrayByKey(retObj, data.sortKey, data.sortDir));
        }
      });
    } catch (e) {
      console.error(e);
    }
  };

  /**
   *
   * @param {collection, criteria, sort, limit, skip, project} data
   * @returns {Promise<Array|*>}
   */
  mongo.getDocumentsWithMergeAsync = async function (data) {
    if (!data.collection) throw new Error('collection is not defined');
    if (!data.criteria) throw new Error('criteria is not defined');
    if (!data.sortKey) throw new Error('sortKey is not defined');
    if (!data.sortDir) throw new Error('sortDir is not defined');

    if (!data.limit) data.limit = 200;
    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;
    if (!data.project) data.project = {};

    let mc_us = mongoClientUs;
    let mc_eu = mongoClientEu;
    let retObj = [];

    try {
      console.log("[MONGO] - getting documents from US db");
      let collection_us = mc_us.collection("BP_" + data.collection);
      let cursor_us = collection_us.find(data.criteria);

      cursor_us.project(data.project);
      cursor_us.sort(data.sort);
      cursor_us.limit(data.limit);
      cursor_us.skip(data.skip);
      let objs = await cursor_us.toArray()
      if (objs) retObj = objs;


      if (config.Mongo.connectionString !== config.Mongo_EU.connectionString) {
        console.log("[MONGO] - getting documents from EU db");
        let collection_eu = mc_eu.collection("BP_" + data.collection);
        let cursor_eu = collection_eu.find(data.criteria);

        cursor_eu.project(data.project);
        cursor_eu.sort(data.sort);
        cursor_eu.limit(data.limit);
        cursor_eu.skip(data.skip);
        objs = await cursor_eu.toArray()
        if (objs) {
          console.log("[MONGO] - merging documents from US and EU dbs");
          retObj = retObj.concat(objs);
        }
        return _.take(helpers.sortObjectArrayByKey(retObj, data.sortKey, data.sortDir), data.limit)
      } else {
        console.log("[MONGO] - db connection strings are the same, not merging data");
        return helpers.sortObjectArrayByKey(retObj, data.sortKey, data.sortDir);
      }
    } catch (e) {
      console.error(e);
    }
  };

  // data{collection, criteria, sort, limit, skip}
  mongo.getPagingDocuments = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    if (!data.limit) data.limit = 200;
    if (!data.sort) data.sort = {};
    if (!data.skip) data.skip = 0;

    let mc = chooseMongoClient(data.collection, data.criteria);
    try {
      let collection = mc.collection("BP_" + data.collection),
        cursor = collection.find(data.criteria, {
          skip: data.skip,
          limit: data.limit
        });
      cursor.sort(data.sort);
      cursor.toArray(function (error, objs) {
        if (error) console.error('Error: getDocuments ' + error.message);
        if (!objs) objs = [];

        return callback(error, objs);
      });
    } catch (e) {
      console.error(e);
    }
  };

  // data{collection, criteria}
  mongo.deleteDocument = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));

    let mc = chooseMongoClient(data.collection, data.criteria),
      collection = mc.collection("BP_" + data.collection);

    collection.remove(data.criteria, function (error, result) {
      if (error) console.error('Error: deleteDocument ' + error.message);
      return callback(error, result);
    });
  };

  /**
   *
   * @param {collection, criteria} data
   * @returns {Promise<*>}
   */
  mongo.deleteDocumentAsync = async function (data) {
    if (!data.collection) throw new Error('collection is not defined');
    if (!data.criteria) throw new Error('criteria is not defined');

    let mc = chooseMongoClient(data.collection, data.criteria);
    let collection = mc.collection("BP_" + data.collection);

    return collection.remove(data.criteria)
  };

  // // data{collection, dbcheck, criteria}
  // mongo.getAggregate = function (data, callback) {
  //   if (!data.collection) return callback(new Error('collection is not defined'));
  //   if (!data.dbcheck) return callback(new Error('dbcheck is not defined'));
  //   if (!data.criteria) return callback(new Error('criteria is not defined'));
  //
  //   try {
  //     let mc = chooseMongoClient(data.collection, data.dbcheck),
  //       collection = mc.collection("BP_" + data.collection);
  //
  //     collection.aggregate(data.criteria, {}, function (error, results) {
  //       if (error) console.error('Error: getAggregate ' + error.message);
  //       if (!results) results = [];
  //
  //       return callback(null, results);
  //     });
  //   } catch (e) {
  //     console.error(e);
  //     return callback(e, null);
  //   }
  // };
  mongo.getAggregate = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.dbcheck) return callback(new Error('dbcheck is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    try {
      let mc = chooseMongoClient(data.collection, data.dbcheck),
        collection = mc.collection("BP_" + data.collection);
      collection.aggregate(data.criteria, {}, function (error, cursor) {
        if (error) {
          console.error('Error: getAggregate ' + error.message);
          return callback(error)
        }
        if (!cursor) return callback(null, []);
        cursor.toArray(function (err, documents) {
          return callback(null, documents);
        });
      });
    } catch (e) {
      console.error(e);
      return callback(e, null);
    }
  };

  // data{collection, criteria, project, sort, limit, skip, sortKey, sortDir}
  mongo.getAggregateWithMerge = function (data, callback) {
    if (!data.collection) return callback(new Error('collection is not defined'));
    if (!data.criteria) return callback(new Error('criteria is not defined'));
    if (!data.sortKey) return callback(new Error('sortKey is not defined'));
    if (!data.sortDir) return callback(new Error('sortDir is not defined'));

    if (!data.limit) data.limit = 200;

    let mc_us = mongoClientUs,
      mc_eu = mongoClientEu,
      retObj = [];

    try {
      console.log("[MONGO] - getting documents from US db");
      let collection_us = mc_us.collection("BP_" + data.collection)

      collection_us.aggregate(data.criteria, {}, function (error, results) {

        if (error) console.error('Error: getAggregate ' + error.message);
        if (!results) results = [];

        retObj = results;

        if (config.Mongo.connectionString !== config.Mongo_EU.connectionString) {
          console.log("[MONGO] - getting documents from EU db");
          let collection_eu = mc_eu.collection("BP_" + data.collection)

          collection_eu.aggregate(data.criteria, {}, function (error, results) {
            if (error) console.error('Error: getAggregate ' + error.message);
            if (results) {
              console.log("[MONGO] - merging documents from US and EU dbs");
              retObj = retObj.concat(results);
            }
            return callback(error, _.take(helpers.sortObjectArrayByKey(retObj, data.sortKey, data.sortDir), data.limit));
          });
        } else {
          console.log("[MONGO] - db connection strings are the same, not merging data");
          return callback(error, retObj);
        }
      });
    } catch (e) {
      console.error(e);
    }
  };

  return mongo;
};

function chooseMongoClient(collection, data) {
  if (mongoConstants.IGNORE_COLLECTIONS.indexOf(collection) === -1) {
    //console.log("CHOOSING MONGO CLIENT:", collection, JSON.stringify(data));
    for (let i = 0; i < mongoConstants.CHECK_FIELDS.length; i++) {
      if (data instanceof Array) {
        let use_eu = false;
        data.forEach(function (element) {
          let id = element[mongoConstants.CHECK_FIELDS[i]];
          if (id && id.length === 14 && id.slice(-2) === config.region_codes.eu) {
            console.log("[MONGO] - USING EU DB FOR:", collection);
            use_eu = true;
          }
        });
        if (use_eu) {
          return mongoClientEu;
        }
      } else {
        let id = data[mongoConstants.CHECK_FIELDS[i]];
        if (id && id.length === 14 && id.slice(-2) === config.region_codes.eu) {
          //console.log("[MONGO] - USING EU DB FOR:", collection);
          return mongoClientEu;
        }
      }
    }
  } else {
    //console.log("[MONGO] - FORCING US DB FOR:", collection);
    return mongoClientUs;
  }
  return mongoClientUs;
}
