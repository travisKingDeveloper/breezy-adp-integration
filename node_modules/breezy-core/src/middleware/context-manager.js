'use strict'

const cls = require('cls-hooked')
const {buildAccessManager} = require('../lib/security/core-security')
const uuid = require('uuidv4')
const companyClient = require('../lib/company/core-company')
const userClient = require('../lib/user/core-user')
const positionClient = require('../lib/position/core-position')
const candidateClient = require('../lib/candidate/core-candidate')
const recruiterClient = require('../lib/recruiter/core-recruiter')
const services = require('../services')
const helpers = require('../util/helpers')
const LOG_NS = '[CONTEXT]'
const SLACK_USER_TYPE = 'slack'
const EXTERNAL_USER_TYPE = 'external'
const RECRUITER_USER_TYPE = 'recruiter'

// generate a unique value for namespace
const nsid = `breezy_context:${uuid()}`
const ns = cls.createNamespace(nsid)
let lastCleaned = Date.now()

/**
 * Tool for some context debug
 * @param source
 * @returns {Function}
 */
const contextLogger = (source) => {
  return (req, res, next) => {
    console.log(LOG_NS, source, 'query  ', JSON.stringify(req.query))
    console.log(LOG_NS, source, 'params  ', JSON.stringify(req.params))
    next()
  }
}

/**
 * Creates a position context if conditions are met
 * @returns {Function}
 */
const positionContext = (remote = false) => {
  return async (req, res, next) => {
    ns.bindEmitter(req)
    ns.bindEmitter(res)

    // Handle Position Context
    let positionId
    let position

    if (req.params.positionId) {
      positionId = req.params.positionId
    } else if (req.query.position_id) {
      positionId = req.query.position_id
    } else if (req.body && req.body.position_id) {
      positionId = req.body.position_id
    }

    if (positionId) {
      if (remote) {
        let company = await ns.get('company')
        if (company) {
          let companyUser = await ns.get('user')
          position = services.positionService.getPosition(company._id, positionId, companyUser)
        } else {
          console.warn(LOG_NS, 'Missing company to get position')
        }
      } else {
        position = positionClient.getPositionWithContext(positionId, await user(), await company(), await security())
      }
    }

    ns.set('position', position)
    next()
  }
}

/**
 * Creates a company context and security context if conditions are met
 * @returns {Function}
 */
const companyContext = (remote = false) => {
  return async (req, res, next) => {
    ns.bindEmitter(req)
    ns.bindEmitter(res)

    // Handle Company Context
    let companyId
    let company

    if (req.params.companyId) {
      companyId = req.params.companyId
    } else if (req.query.company_id) {
      companyId = req.query.company_id
    } else if (req.body && req.body.company_id) {
      companyId = req.body.company_id
    }

    if (companyId) {
      let companyUser = ns.get('user')
      if (remote) {
        company = services.companyService.getCompany(companyId, await companyUser)
      } else {
        try {
          company = companyClient.getCompanyById(companyId, companyClient.COMPANY_OPTIONS.COMPANY_FEATURES)
        } catch (e) {
          console.error(LOG_NS, 'Error building company context', e)
        }

        companyUser = await companyUser
        if (company && companyUser) {
          companyUser = companyClient.populateCompanyUserMeta(companyId, companyUser)
          ns.set('user', companyUser)
        }
      }
    }

    ns.set('company', company)

    //if we have a company context we should be able to assemble a security context...
    buildSecurityContext(req, next)
  }
}

/**
 * Creates a candidate context if conditions are met
 * @returns {Function}
 */
const candidateContext = (remote = false) => {
  return async (req, res, next) => {
    ns.bindEmitter(req)
    ns.bindEmitter(res)

    // Handle Company Context
    let candidateId
    let candidate

    if (req.params.candidateId) {
      candidateId = req.params.candidateId
    } else if (req.query.candidate_id) {
      candidateId = req.query.candidate_id
    } else if (req.body && req.body.candidate_id) {
      candidateId = req.body.candidate_id
    }

    if (candidateId) {

      if (remote) {
        let company = await ns.get('company')
        let position = await ns.get('position')
        if (company && position) {
          let companyUser = await ns.get('user')
          candidate = services.candidateService.getCandidate(company._id, position._id, candidateId, companyUser)
        } else {
          console.warn(LOG_NS, 'Missing company and or position to get candidate')
        }
      } else {
        candidate = candidateClient.getCandidateById(candidateId)
      }
    }

    ns.set('candidate', candidate)
    next()
  }
}

/**
 * Builds the security context and adds the promise to the namespace context
 * @param req
 * @param next
 */
const buildSecurityContext = (req, next) => {

  let security = buildAccessManager(user(), company())

  ns.set('security', security)

  next()
}

/**
 * user context manager middleware for express
 * @returns {Function}
 */
const requestContext = () => {
  return (req, res, next) => {
    ns.bindEmitter(req)
    ns.bindEmitter(res)

    // Handle User Context
    let userId
    let user

    if (req.query.acting_user_id) {
      userId = req.query.acting_user_id
    } else if (req.body && req.body.acting_user_id) {
      userId = req.body.acting_user_id
    }

    if (req.query.acting_user_type) {
      if (req.query.acting_user_type === SLACK_USER_TYPE) {
        user = _getSlackUser(userId, req.query.acting_user_name)
      } else if (req.query.acting_user_type === EXTERNAL_USER_TYPE) {
        user = _getExternalUser(userId, req.query.acting_user_name)
      } else if (req.query.acting_user_type === RECRUITER_USER_TYPE) {
        if (userId) {
          user = recruiterClient.getRecruiterById(userId)
        }
      }
    } else {
      if (userId) {
        //this is just stashing a promise for later...
        user = userClient.getUserById(userId)
      }
    }

    ns.run(() => {
      ns.set('ts', Date.now())
      ns.set('user', user)
      next()
    })
    _initCleanup()
  }
}

function _getSlackUser(actingUserId, actingUserName) {
  console.log('Request from Slack team user: ' + actingUserId)
  let slackUser = {}
  slackUser._id = actingUserId
  slackUser.name = actingUserName + ' (Slack)'
  slackUser.initial = slackUser.name[0]
  slackUser.hex_color = helpers.getColorFromHexValue(slackUser.name)
  slackUser.type = 'slack'
  return slackUser
}

function _getExternalUser(actingUserId, actingUserName) {
  console.log('Request from external team user: ' + actingUserId)
  let externalUser = {}
  externalUser._id = actingUserId
  externalUser.name = actingUserName + ' (External)'
  externalUser.initial = externalUser.name[0]
  externalUser.hex_color = helpers.getColorFromHexValue(externalUser.name)
  externalUser.type = 'external'
  return externalUser
}

function _initCleanup() {
  if (Date.now() > lastCleaned + 300000) {
    lastCleaned = Date.now()
    _contextCleanup()
  }
}

function _contextCleanup() {
  let keys = [...ns._contexts.keys()];
  let count = 0
  for (let key of keys) {
    let value = ns._contexts.get(key)
    if (value && value.ts && (Date.now() - value.ts) > 120000) {
      ns._contexts.delete(key)
      count++
    }
  }

  keys = [...ns._contexts.keys()];
  console.log(LOG_NS, 'context keys', keys.length, 'cleaned', count)
}

/**
 * Returns appropriate context
 * @returns {*}
 */
const security = async () => ns.get('security')
const user = async () => ns.get('user')
const company = async () => ns.get('company')
const position = async () => ns.get('position')
const candidate = async () => ns.get('candidate')
const set = (key, object) => ns.set(key, object)

module.exports = {
  positionContext,
  companyContext,
  contextLogger,
  requestContext,
  candidateContext,
  context: {
    security,
    user,
    company,
    position,
    candidate,
    set
  }
}
