'use strict'

const {PERMISSION, ACCESS} = require('../../data/security-config')
const USER_NIMBLEBOT = 'nimblebot'
const LOG_NS = '[SECURITY]'
const SCOPE_ALL = 'all_scopes'

/**
 * @typedef {object} Security
 * @property {string} userId
 * @property {string} companyId
 * @property {Array} roles
 * @property {object} positionRoles
 * @property {Object} permissions
 */

/**
 * validateAgainst - validates against a permission requirement
 * @param {string} id - just for debug
 * @param {number} permission
 * @param {number} permissionTarget
 */
function _validateAgainst(id, permission, permissionTarget) {
  return (permissionTarget & permission) === permissionTarget
}


class AccessManager {

  /**
   * Creates an access manager for a user and a specific company definition
   * @param {Security} security
   */
  constructor(security) {

    this._user_id = security.userId
    this._company_id = security.companyId
    this._roles = security.roles
    this._positionRoles = security.positionRoles
    this._permissions = security.permissions
  }

  /**
   * Verify a user access to functionality
   * @param {string} id
   * @param {PermissionAccess} requires
   * @param {string} [scope]
   * @returns {boolean|*}
   */
  userCan(id, {create = 0, read = 0, update = 0, remove = 0}, scope) {

    let scopeMessage = ''

    //who can? nimblebot can!
    if (USER_NIMBLEBOT === this._user_id) {
      return true
    }

    let permission = 0

    if (scope) {
      scopeMessage = ' with scope ' + scope
      let roles = this._getRoles(scope)
      for (let role of roles) {
        let rolePermission = this._permissions[role][id]
        permission = mergePermissions(permission, rolePermission)
      }
    }

    if (!this._permissions || this._permissions.size === 0) {
      //console.info(LOG_NS, `No Permissions defined for user ${this._user_id} from company ${this._company_id}`)
      return false
    }

    if (!id || (!(id in this._permissions) && permission === 0)) {
      //console.info(LOG_NS, `User ${this._user_id} from company ${this._company_id} does not have permission ${id}${scopeMessage}`)
      return false
    }

    permission = mergePermissions(permission, this._permissions[id])

    if (_validateAgainst(id, permission, securityRequirement({
      create: create,
      read: read,
      update: update,
      remove: remove
    }))) {
      return true
    } else {
      //console.info(LOG_NS, `User ${this._user_id} from company ${this._company_id} is denied access via permission ${id}${scopeMessage}`)
      return false
    }
  }

  /**
   * Collects roles based on a scope id
   * @param scope
   * @returns {Array}
   * @private
   */
  _getRoles(scope) {
    let roles = []
    for (let role of this._roles) {
      if (role in this._positionRoles) {
        if ((scope === SCOPE_ALL) || (this._positionRoles[role].indexOf(scope) >= 0)) {
          roles.push(role)
        }
      }
    }
    return roles
  }

  /**
   * Gets teh acting user Id
   * @returns {string}
   */
  getUserId() {
    return this._user_id
  }

  /**
   * Gets the current company id
   * @returns {string}
   */
  getCompanyId() {
    return this._company_id
  }

  /**
   * gets the acting user's roles
   * @returns {string[]}
   */
  getRoles() {
    return this._roles
  }

  /**
   * Exports the security model
   * @returns {{companyId: string, permissions: Object, roles: Array, positionRoles: Object, userId: string}}
   */
  export(scope) {

    let model = {
      userId: this._user_id,
      companyId: this._company_id,
      roles: [],
      positionRoles: {},
      permissions: {}
    }

    if (!scope) {
      Object.assign(model.roles, this._roles)
      Object.assign(model.positionRoles, this._positionRoles)
      Object.assign(model.permissions, this._permissions)
      return model
    }

    Object.assign(model.permissions, this._permissions)

    for (let role of this._roles) {
      if (role in this._positionRoles) {
        if (this._positionRoles[role].indexOf(scope) >= 0) {
          model.positionRoles[role] = [scope]
          model.roles.push(role)
        } else {
          delete model.permissions[role]
        }
      } else {
        model.roles.push(role)
      }
    }

    return model
  }
}

/**
 * Permission structure to bit
 * @param permissionsValues
 * @returns {number}
 */
function securityRequirement(permissionsValues = {}) {

  let create = permissionsValues.create | 0
  let read = (permissionsValues.read | 0) << 1
  let update = (permissionsValues.update | 0) << 2
  let remove = (permissionsValues.remove | 0) << 3
  return create | read | update | remove
}

/**
 * Merges two permission values via bitwise or
 * @param permission
 * @param targetPermission
 * @returns {number}
 */
function mergePermissions(permission, targetPermission) {
  return permission | targetPermission
}

module.exports = {
  PERMISSION,
  ACCESS,
  SCOPE_ALL,
  AccessManager,
  securityRequirement,
  mergePermissions
}